//GBX:Zoner - Refactored this, its much more simplistic than epics, shouldn't need any epic changes ever on this file

#ifndef SHADOWMAP_KERNEL_SIZE
#define SHADOWMAP_KERNEL_SIZE 1
#endif


#define USE_RECEIVER_PLANE_BIAS 1

sampler2D ShadowDepthTexture;
float4 SampleOffsets[NUM_SAMPLES];
float4 ShadowBufferSizeAndInvSize;	// texture res in xy, 1/texture res in zw

#if SHADOWMAP_KERNEL_SIZE == 5

static const float2 KernelCenter = {0,0};
static const float2 PCFOffsets[SHADOWMAP_KERNEL_SIZE][SHADOWMAP_KERNEL_SIZE] =
{
	{{-2,-2},   {-1, -2},   {0,-2},   {1, -2},   {2,-2}},
	{{-2,-1},   {-1, -1},   {0,-1},   {1, -1},   {2,-1}},
	{{-2, 0},   {-1,  0},   {0, 0},   {1,  0},   {2, 0}},
	{{-2, 1},   {-1,  1},   {0, 1},   {1,  1},   {2, 1}},
	{{-2, 2},   {-1,  2},   {0, 2},   {1,  2},   {2, 2}},
};

#elif SHADOWMAP_KERNEL_SIZE == 4

static const float2 KernelCenter = {0.5,0.5};
static const float2 PCFOffsets[SHADOWMAP_KERNEL_SIZE][SHADOWMAP_KERNEL_SIZE] =
{
	{{-1.5,-1.5},   {-0.5, -1.5},   {0.5,-1.5},   {1.5, -1.5}},
	{{-1.5,-0.5},   {-0.5, -0.5},   {0.5,-0.5},   {1.5, -0.5}},
	{{-1.5, 0.5},   {-0.5,  0.5},   {0.5, 0.5},   {1.5,  0.5}},
	{{-1.5, 1.5},   {-0.5,  1.5},   {0.5, 1.5},   {1.5,  1.5}},
};

#elif SHADOWMAP_KERNEL_SIZE == 3

static const float2 KernelCenter = {0,0};
static const float2 PCFOffsets[SHADOWMAP_KERNEL_SIZE][SHADOWMAP_KERNEL_SIZE] =
{
	{{-1, -1},   {0,-1},   {1, -1}},
	{{-1,  0},   {0, 0},   {1,  0}},
	{{-1,  1},   {0, 1},   {1,  1}},
};

#elif SHADOWMAP_KERNEL_SIZE == 2

static const float2 KernelCenter = {0.5,0.5};
static const float2 PCFOffsets[SHADOWMAP_KERNEL_SIZE][SHADOWMAP_KERNEL_SIZE] =
{
	{{-0.5, -0.5},   {0.5,-0.5}},
	{{-0.5,  0.5},   {0.5, 0.5}},
};

#endif


#if XBOX

float SampleShadowmap(float2 TexCoord, float SceneDepth, float2 Offsets)
{
	float ShadowDepth;
	float MyOffsetX = Offsets.x;
	float MyOffsetY = Offsets.y;
	asm
	{
		tfetch2D ShadowDepth.x___, TexCoord.xy, ShadowDepthTexture, MinFilter = point, MagFilter = point, AnisoFilter = disabled, OffsetX = MyOffsetX, OffsetY = MyOffsetY
	};
	float Result = SceneDepth < ShadowDepth ? 1 : 0;
	return Result;
}

#else

float SampleShadowmap(float2 TexCoord, float SceneDepth, float2 Offsets)
{
	float2 FinalOffset = Offsets;
	float ShadowDepth = texDepth2D(ShadowDepthTexture,TexCoord+FinalOffset).r;
	float Result = SceneDepth < ShadowDepth ? 1 : 0;
	return Result;
}

float SampleShadowmapFetch4(float2 TexCoord, float SceneDepth, float2 Offsets)
{
	float2 FinalOffset = Offsets;
	float4 ShadowDepth = texDepth2D(ShadowDepthTexture,TexCoord+FinalOffset).rgba;
	float4 Result = SceneDepth.xxxx < ShadowDepth ? 1.f.xxxx : 0.f.xxxx;
	return dot(Result, 0.25f.xxxx);
}

#endif


/**
* Takes samples and compares and averages manually.
*
* @return a PCF value between 0 and 1
*/


float ManualPCF(float4 InShadowPosition)
{
	float Shadow = 0;

#if (SHADOWMAP_KERNEL_SIZE == 5) || (SHADOWMAP_KERNEL_SIZE == 4) || (SHADOWMAP_KERNEL_SIZE == 3) || (SHADOWMAP_KERNEL_SIZE == 2)
	float4 ShadowPosition = InShadowPosition;
	float2 ShadowCoord = ShadowPosition.xy;
	
	float ShadowResult[SHADOWMAP_KERNEL_SIZE][SHADOWMAP_KERNEL_SIZE];

	UNROLL
	for (int y=0; y<SHADOWMAP_KERNEL_SIZE; ++y)
	{
		UNROLL
		for (int x=0; x<SHADOWMAP_KERNEL_SIZE; ++x)
		{
#if XBOX
			ShadowResult[y][x] = SampleShadowmap(ShadowCoord, ShadowPosition.z, PCFOffsets[y][x]);
#else
			ShadowResult[y][x] = SampleShadowmap(ShadowCoord, ShadowPosition.z, SampleOffsets[y*SHADOWMAP_KERNEL_SIZE+x]);
#endif
		}
	}

	float2 ShadowBufferSize = ShadowBufferSizeAndInvSize.xy;
	float2 FracOffset = KernelCenter * ShadowBufferSizeAndInvSize.zw;
	float2 FilterWeights = (float2)1.0 - frac((ShadowCoord.xy+FracOffset) * ShadowBufferSize.xy);
    
    float CornerAB   = lerp(ShadowResult[0][SHADOWMAP_KERNEL_SIZE-1],             ShadowResult[0][0], FilterWeights.x);
    float CornerCD   = lerp(ShadowResult[SHADOWMAP_KERNEL_SIZE-1][SHADOWMAP_KERNEL_SIZE-1], ShadowResult[SHADOWMAP_KERNEL_SIZE-1][0], FilterWeights.x);

    float CornerSum = lerp(CornerCD, CornerAB, FilterWeights.y);
    float EdgeHorizSum = 0;
    float EdgeVertSum = 0;
    float CenterSum = 0;
    
	UNROLL    
    for (int y=1; y<(SHADOWMAP_KERNEL_SIZE-1); ++y)
    {
    	EdgeHorizSum += lerp(ShadowResult[y][SHADOWMAP_KERNEL_SIZE-1], ShadowResult[y][0], FilterWeights.x);
	}
    
    UNROLL
    for (int x=1; x<(SHADOWMAP_KERNEL_SIZE-1); ++x)
    {
    	EdgeVertSum += lerp(ShadowResult[SHADOWMAP_KERNEL_SIZE-1][x], ShadowResult[0][x], FilterWeights.y);
	}

	UNROLL
    for (int y=1; y<(SHADOWMAP_KERNEL_SIZE-1); ++y)
    {
    	UNROLL
    	for (int x=1; x<(SHADOWMAP_KERNEL_SIZE-1); ++x)
    	{
    		CenterSum += ShadowResult[y][x];
    	}
    }
	
    float TotalWeight = CornerSum + EdgeHorizSum + EdgeVertSum + CenterSum;

	Shadow = TotalWeight / ((SHADOWMAP_KERNEL_SIZE-1) * (SHADOWMAP_KERNEL_SIZE-1));
	
#else

	float2 ShadowPosition = InShadowPosition.xy;
	float ShadowDepth = InShadowPosition.z;
	
	UNROLL
	for(int SampleIndex = 0;SampleIndex < NUM_SAMPLES; ++SampleIndex)
	{
		float2 SampleUV = (ShadowPosition.xy + SampleOffsets[SampleIndex].xy);
		
		float TestDepth = texDepth2D(ShadowDepthTexture, SampleUV.xy).r;
		
		Shadow += (ShadowDepth < TestDepth) ? 1.0 : 0.0;
	}

	Shadow *= 1.0 / float(NUM_SAMPLES);

#endif

	Shadow = saturate(Shadow);

	return Shadow;
}

/**
* Takes samples, compares and billinear filtering are done by hardware.
*
* @return a PCF value between 0 and 1
*/
float HardwarePCF(float4 InShadowPosition)
{
	float Shadow = 0;

	float4 ShadowPosition = float4(InShadowPosition.x, InShadowPosition.y, InShadowPosition.z, 1);

	UNROLL
	for(int SampleIndex = 0; SampleIndex < NUM_SAMPLES; ++SampleIndex)
	{
		float PCFWeight = texDepth2Dproj(ShadowDepthTexture,ShadowPosition + SampleOffsets[SampleIndex]).r;
		
		Shadow += PCFWeight;
	}
	
	Shadow *= 1.0 / float(NUM_SAMPLES);

	Shadow = saturate(Shadow);

	return Shadow;
}

float3 ReceiverPlaneSMDepthGradientNrm(float3 smapPos)
{
	const float3	smPosDx		= normalize(ddx(smapPos));
	const float3	smPosDy		= normalize(ddy(smapPos));
	const float3	nrm 		= cross(smPosDx, smPosDy);
	const float		oneOverNrmZ	= 1.0f / nrm.z;

	return float3(-nrm.xy * oneOverNrmZ, nrm.z);	
}

float3 ReceiverPlaneSMDepthGradient(float3 smapPos)
{
	const float3	smPosDx		= ddx(smapPos);
	const float3	smPosDy		= ddy(smapPos);
	const float3	nrm 		= cross(smPosDx, smPosDy);
	const float		oneOverNrmZ	= 1.0f / nrm.z;

	return float3(-nrm.xy * oneOverNrmZ, nrm.z);	
}

float HWPCFFetchSingle(float4 shadowPos)
{
#if ORBIS
	return ShadowDepthTexture.texture.SampleCmpLevelZero(ShadowDepthTexture.sampler, shadowPos, shadowPos.z);
#elif DINGO
	return ShadowDepthTexture.textureQQ.SampleCmpLevelZero(ShadowDepthTexture.samplerQQ, shadowPos, shadowPos.z);
#else
	return texDepth2Dproj(ShadowDepthTexture, shadowPos).r;
#endif
}

float HardwarePCFNew(float4 InShadowPosition, float2 screenPos, float2 receiverDGrad)
{
	const float		rndInput		= dot(float2(0.06711056f, 0.00583715f), screenPos);
	const float 	rnd				= frac(52.9829189f * frac(rndInput));
	float4			shadowPos;
	float			Shadow			= 0;
	float2			rbasis;

	sincos(rnd * 6.28318530718f, rbasis.x, rbasis.y);

	shadowPos.w = InShadowPosition.w;

	UNROLL
	for(int SampleIndex = 0; SampleIndex < NUM_SAMPLES / 2; ++SampleIndex)
	{
		const float2 offs0 = SampleOffsets[2 * SampleIndex + 0].xy * rbasis.xy;
		const float2 offs1 = SampleOffsets[2 * SampleIndex + 1].xy * rbasis.yx;
	
		shadowPos.xy = InShadowPosition.xy + offs0;

#if USE_RECEIVER_PLANE_BIAS
		shadowPos.z  = InShadowPosition.z + dot(offs0, receiverDGrad);
#else
		shadowPos.z = InShadowPosition.z;
#endif

		Shadow += HWPCFFetchSingle(shadowPos);

		
		shadowPos.xy = InShadowPosition.xy + offs1;

#if USE_RECEIVER_PLANE_BIAS
		shadowPos.z  = InShadowPosition.z + dot(offs1, receiverDGrad);
#else
		shadowPos.z  = InShadowPosition.z;
#endif

		Shadow += HWPCFFetchSingle(shadowPos);
	}
	
	Shadow *= 1.0 / float(NUM_SAMPLES);

	Shadow = saturate(Shadow);

	return Shadow;
}



float Fetch4PCF(float4 InShadowPosition)
{
	float Shadow = 0;

#if PC_D3D
#if (SHADOWMAP_KERNEL_SIZE == 5) || (SHADOWMAP_KERNEL_SIZE == 4) || (SHADOWMAP_KERNEL_SIZE == 3) || (SHADOWMAP_KERNEL_SIZE == 2)
	float4 ShadowPosition = InShadowPosition;
	float2 ShadowCoord = ShadowPosition.xy;
	
	float ShadowResult[SHADOWMAP_KERNEL_SIZE][SHADOWMAP_KERNEL_SIZE];

	UNROLL
	for (int y=0; y<SHADOWMAP_KERNEL_SIZE; ++y)
	{
		UNROLL
		for (int x=0; x<SHADOWMAP_KERNEL_SIZE; ++x)
		{
#if XBOX
			ShadowResult[y][x] = SampleShadowmapFetch4(ShadowCoord, ShadowPosition.z, PCFOffsets[y][x]);
#else
			ShadowResult[y][x] = SampleShadowmapFetch4(ShadowCoord, ShadowPosition.z, SampleOffsets[y*SHADOWMAP_KERNEL_SIZE+x]);
#endif
		}
	}

	float2 ShadowBufferSize = ShadowBufferSizeAndInvSize.xy;
	float2 FracOffset = KernelCenter * ShadowBufferSizeAndInvSize.zw;
	float2 FilterWeights = (float2)1.0 - frac((ShadowCoord.xy+FracOffset) * ShadowBufferSize.xy);
    
    float CornerAB   = lerp(ShadowResult[0][SHADOWMAP_KERNEL_SIZE-1],             ShadowResult[0][0], FilterWeights.x);
    float CornerCD   = lerp(ShadowResult[SHADOWMAP_KERNEL_SIZE-1][SHADOWMAP_KERNEL_SIZE-1], ShadowResult[SHADOWMAP_KERNEL_SIZE-1][0], FilterWeights.x);

    float CornerSum = lerp(CornerCD, CornerAB, FilterWeights.y);
    float EdgeHorizSum = 0;
    float EdgeVertSum = 0;
    float CenterSum = 0;
    
	UNROLL    
    for (int y=1; y<(SHADOWMAP_KERNEL_SIZE-1); ++y)
    {
    	EdgeHorizSum += lerp(ShadowResult[y][SHADOWMAP_KERNEL_SIZE-1], ShadowResult[y][0], FilterWeights.x);
	}
    
    UNROLL
    for (int x=1; x<(SHADOWMAP_KERNEL_SIZE-1); ++x)
    {
    	EdgeVertSum += lerp(ShadowResult[SHADOWMAP_KERNEL_SIZE-1][x], ShadowResult[0][x], FilterWeights.y);
	}

	UNROLL
    for (int y=1; y<(SHADOWMAP_KERNEL_SIZE-1); ++y)
    {
    	UNROLL
    	for (int x=1; x<(SHADOWMAP_KERNEL_SIZE-1); ++x)
    	{
    		CenterSum += ShadowResult[y][x];
    	}
    }
	
    float TotalWeight = CornerSum + EdgeHorizSum + EdgeVertSum + CenterSum;

	Shadow = TotalWeight / ((SHADOWMAP_KERNEL_SIZE-1) * (SHADOWMAP_KERNEL_SIZE-1));
	
#else

	float2 ShadowPosition = InShadowPosition.xy;
	float ShadowDepth = InShadowPosition.z;
	
	UNROLL
	for(int SampleIndex = 0;SampleIndex < NUM_SAMPLES; ++SampleIndex)
	{
		float2 SampleUV = (ShadowPosition.xy + SampleOffsets[SampleIndex].xy);
		
		float4 TestDepth = texDepth2D(ShadowDepthTexture, SampleUV.xy).rgba;

		float4 ShadowTestRslt = (ShadowDepth.xxxx < TestDepth) ? 1.f.xxxx : 0.f.xxxx;
		
		Shadow += dot(ShadowTestRslt, 0.25f.xxxx);
	}

	Shadow *= 1.f / float(NUM_SAMPLES);

#endif
#endif
	Shadow = saturate(Shadow);

	return Shadow;
}

