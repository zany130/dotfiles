//	#define SSAO_USE_HIGH_PRECISION_DEPTH_ENCODING 1


	#define SSAO_PI 							3.14159265359f

	#define SSAO_INTERLEAVED_SAMPLING_NSAMPLES 	2		// resulting number of samples is 4 * SSAO_INTERLEAVED_SAMPLING_NSAMPLES (we sample along 4 axes)
	#define SSAO_SCREENSPACE_RADIUS_NEAR		0.04f
	#define SSAO_SCREENSPACE_RADIUS_FAR			0.02f

	#define SSAO_BLUR_DEPTH_DIFF_THRESHOLD		0.025f
	#define SSAO_BLUR_DEPTH_DIFF_THRESHOLD_LO	(1.0f - SSAO_BLUR_DEPTH_DIFF_THRESHOLD)
	#define SSAO_BLUR_DEPTH_DIFF_THRESHOLD_HI	(1.0f + SSAO_BLUR_DEPTH_DIFF_THRESHOLD)


	// This helps in outdoors, where large portion of screen is potentially covered by skybox (which does not receive AO) and
	// hopefully it does not hurt indoors (where whole screen receives AO)
	#define SSAO_ENABLE_DEPTH_BASED_BRANCH_OPT 1


	struct S_SSAOEvalCtx
	{
		float2	uv;
		float2	screenPos;
		float4	projInfo;
		float2	srcTexelSize;
		float	maxAODist;

		// reasonable values <1, 2>
		float	AOIntensity;

		// default value 0.05
		float	AOBias;

		// default value 0.15
		float	AODistScale;

		// default value 0.2
		float	AOSelfOcclusionBias;
	};

	struct S_SSAOBlurEvalCtx
	{
		float2	uv;
		float4	depthNeighbourSamplesUV_0_1;
		float4	depthNeighbourSamplesUV_2_3;
		float	maxAODist;
	};


	static const float3 SSAO_InterleavedSampingAxes[9] =
	{
		float3(1.000000, 0.000000, 0.700000),
		float3(0.866025, 0.500000, 0.400000),
		float3(0.500000, 0.866025, 0.200000),
		float3(0.766044, 0.642788, 0.300000),
		float3(0.342020, 0.939693, 0.500000),
		float3(0.984808, 0.173648, 0.900000),
		float3(0.173648, 0.984808, 0.000000),
		float3(0.642788, 0.766044, 0.600000),
		float3(0.939693, 0.342020, 0.100000)
	};

	float2 SSAO_EncodeNrmDepth(float v)
	{
		const float		BASE	= 65535.0f;
		const float2	bitSh	= float2(BASE, 1.0f);
		const float2	bitMsk	= float2(0.0f, 1.0f / BASE);

		float2 res = frac(bitSh * v);

		res -= res.xx * bitMsk;

		return res;
	}

	float SSAO_DecodeNrmDepth(float2 v)
	{
		const float		BASE  = 65535.0f;

		return v.x * (1.0f / BASE) + v.y;
	}

	float SSAO_SampleNrmDepth(float2 uv)
	{
#if SSAO_USE_HIGH_PRECISION_DEPTH_ENCODING
		return SSAO_DecodeNrmDepth(tex2Dlod(AmbientOcclusionTexture, float4(uv, 0, 0)).xy);
#else
		return tex2Dlod(AmbientOcclusionTexture, float4(uv, 0, 0)).y;
#endif
	}

	float SSAO_SampleDepth(float2 uv, float maxAODist)
	{
		return SSAO_SampleNrmDepth(uv) * maxAODist;
	}

	float3 SSAO_GetInterleavedSamplingPattern(int2 screenPos)
	{
		const float2	tileCoords	= floor(fmod((float2)screenPos, 3.0f));
		const float2	isOdd 		= frac((float2)screenPos * 0.5) * 2.0f;
		float3			res			= SSAO_InterleavedSampingAxes[(int)(tileCoords.y * 3 + tileCoords.x)];
		
		res.xy = abs(isOdd.x - isOdd.y) > 0.0f ?  res.xy : float2(res.x + res.y, res.y - res.x) * (1.0f / sqrt(2));

		return res;
	}

	float3 SSAO_GetViewSpacePosFromDepth(float2 uv, float depth, float4 projInfo)
	{
		const float3 res = float3((uv * projInfo.xy + projInfo.zw) * depth, depth);

		return res;
	}

	float3 SSAO_GetViewSpacePosAtUV(float2 uv, float4 projInfo, float maxAODist)
	{
		float depth = SSAO_SampleDepth(uv, maxAODist);

		return SSAO_GetViewSpacePosFromDepth(uv, depth, projInfo);
	}

	float3 SSAO_MinDiff(float3 P, float3 Pr, float3 Pl)
	{
	    float3 V1 = Pr - P;
	    float3 V2 = P - Pl;

	    float l0 = dot(V1, V1);
	    float l1 = dot(V2, V2);

	    return l0 < l1 ? V1 : V2;
	}

	float3 SSAO_CalcViewSpaceNormal(float3 viewPos, float2 uv, S_SSAOEvalCtx ctx)
	{
#if PC_D3D
		// This is workaround for issue manifested under D3D9 on PC. I was not able to track it down, but it definitely has something to do with precision of depth data. The issue is,
		// that for certain surfaces near the viewer, reconstructed normals are distorted by high frequency patterns. Changing sampling offsets for fixes this.
		const float3	uvOffs = float3(2, -2, 0) * ctx.srcTexelSize.xyy;
#else
		const float3	uvOffs = float3(1, -1, 0) * ctx.srcTexelSize.xyy;
#endif

		const float3	posL = SSAO_GetViewSpacePosAtUV(uv + uvOffs.yz, ctx.projInfo, ctx.maxAODist);
		const float3	posR = SSAO_GetViewSpacePosAtUV(uv + uvOffs.xz, ctx.projInfo, ctx.maxAODist);
		const float3	posT = SSAO_GetViewSpacePosAtUV(uv + uvOffs.zy, ctx.projInfo, ctx.maxAODist);
		const float3	posB = SSAO_GetViewSpacePosAtUV(uv + uvOffs.zx, ctx.projInfo, ctx.maxAODist);

		const float3 	du = SSAO_MinDiff(viewPos, posT, posB);
		const float3 	dv = SSAO_MinDiff(viewPos, posR, posL);

		return normalize(cross(du, dv));
	}


	float SSAO_EvalOcclusion(float3 pos, float3 nrm, float3 samplePos, float angBias, float selfOcclusionBias, float occluderDistScaleSqr)
	{
		const float3	diff 		= samplePos - pos;
		const float		diffLenSqr	= dot(diff, diff);
		const float		att			= 1.0f - saturate(diffLenSqr * occluderDistScaleSqr);
		const float		ang			= max(dot(nrm, diff) * rsqrt(diffLenSqr) - angBias, -selfOcclusionBias);

		return ang * att;
	}

	float2 SSAO_EvalInterleavedSampling(S_SSAOEvalCtx ctx)
	{
		// Uses variation of interleaved sampling technique by JOSE MARÍA MÉNDEZ (Arkano22) / Virtual Method Studio

		const float		nrmDepth			= SSAO_SampleNrmDepth(ctx.uv);

#if SSAO_ENABLE_DEPTH_BASED_BRANCH_OPT
		BRANCH if (nrmDepth < 1.0f) 
		{
#endif
			const float		depth				= nrmDepth * ctx.maxAODist;
			const float3	viewPos				= SSAO_GetViewSpacePosFromDepth(ctx.uv, depth, ctx.projInfo);
			const float		screenSpaceRadius	= lerp(SSAO_SCREENSPACE_RADIUS_NEAR, SSAO_SCREENSPACE_RADIUS_FAR, saturate(viewPos.z / 50));
			const float 	radiusInViewSpace 	= screenSpaceRadius * viewPos.z;
			const float3	viewNrm				= SSAO_CalcViewSpaceNormal(viewPos, ctx.uv, ctx);	
			
			const float3	isamplePattern		= SSAO_GetInterleavedSamplingPattern(ctx.screenPos);				
			const float 	viewSpaceRadiusSqr	= radiusInViewSpace * radiusInViewSpace;
			const float		occlDistScaleSqr	= (ctx.AODistScale * ctx.AODistScale) / viewSpaceRadiusSqr;
			const float2	axis1				= isamplePattern.xy * (screenSpaceRadius / SSAO_INTERLEAVED_SAMPLING_NSAMPLES);
			const float2	axis2				= float2(-axis1.y, axis1.x);
			float			aoSum				= 0.0f;

			// sample along negative direction of axis1
			for (int i = 1; i <= SSAO_INTERLEAVED_SAMPLING_NSAMPLES; i++)
			{
				const float2	sampleUV 		= ctx.uv - axis1.xy * ((float)i - isamplePattern.z);
				const float3	sampleViewPos 	= SSAO_GetViewSpacePosAtUV(sampleUV, ctx.projInfo, ctx.maxAODist);

				aoSum += SSAO_EvalOcclusion(viewPos, viewNrm, sampleViewPos, ctx.AOBias, ctx.AOSelfOcclusionBias, occlDistScaleSqr);
			}

			// sample along positive direction of axis1
			for (int i = 1; i <= SSAO_INTERLEAVED_SAMPLING_NSAMPLES; i++)
			{
				const float2	sampleUV 		= ctx.uv + axis1.xy * ((float)i - isamplePattern.z);
				const float3	sampleViewPos 	= SSAO_GetViewSpacePosAtUV(sampleUV, ctx.projInfo, ctx.maxAODist);

				aoSum += SSAO_EvalOcclusion(viewPos, viewNrm, sampleViewPos, ctx.AOBias, ctx.AOSelfOcclusionBias, occlDistScaleSqr);
			}

			// sample along negative direction of axis2
			for (int i = 1; i <= SSAO_INTERLEAVED_SAMPLING_NSAMPLES; i++)
			{
				const float2	sampleUV 		= ctx.uv - axis2.xy * ((float)i - isamplePattern.z);
				const float3	sampleViewPos 	= SSAO_GetViewSpacePosAtUV(sampleUV, ctx.projInfo, ctx.maxAODist);

				aoSum += SSAO_EvalOcclusion(viewPos, viewNrm, sampleViewPos, ctx.AOBias, ctx.AOSelfOcclusionBias, occlDistScaleSqr);
			}

			// sample along positive direction of axis2
			for (int i = 1; i <= SSAO_INTERLEAVED_SAMPLING_NSAMPLES; i++)
			{
				const float2	sampleUV 		= ctx.uv + axis2.xy * ((float)i - isamplePattern.z);
				const float3	sampleViewPos 	= SSAO_GetViewSpacePosAtUV(sampleUV, ctx.projInfo, ctx.maxAODist);

				aoSum += SSAO_EvalOcclusion(viewPos, viewNrm, sampleViewPos, ctx.AOBias, ctx.AOSelfOcclusionBias, occlDistScaleSqr);
			}

			float ao = saturate(1.0f - (aoSum * ctx.AOIntensity / (SSAO_INTERLEAVED_SAMPLING_NSAMPLES * 4)));

			return float2(ao, nrmDepth);

#if SSAO_ENABLE_DEPTH_BASED_BRANCH_OPT
		}
		else
		{
			return float2(1.0f, nrmDepth);
		}
#endif
	}

